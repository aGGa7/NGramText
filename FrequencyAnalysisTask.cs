//N - грамма — это N соседних слов в одном предложении. 2-граммы называют биграммами. 3-граммы — триграммами.

//Например, из текста: "She stood up. Then she left." можно выделить следующие биграммы "she stood", "stood up", "then she" и "she left", но не "up then". И две триграммы "she stood up" и "then she left", но не "stood up then".

//По списку предложений, составленному в прошлой задаче, составьте словарь самых частотных продолжений биграмм и триграмм. Это словарь, ключами которого являются все возможные начала биграмм и триграмм, а значениями — их самые частотные продолжения.

//Более формально так:

//Для каждой пары (key, value) из словаря должно выполняться одно из следующих условий:

//В тексте есть хотя бы одна биграмма (key, value), и для любой другой присутствующей в тексте биграммы (key, otherValue), начинающейся с того же слова, value должен быть лексикографически меньше otherValue.

//Либо в тексте есть хотя бы одна триграмма (w1, w2, value), такая что w1 + " " + w2 == key и для любой другой присутствующей в тексте триграммы (w1, w2, otherValue), начинающейся с той же пары слов, value должен быть лексикографически меньше otherValue.

//Для лексикографического сравнения используйте встроенный в .NET способ сравнения Ordinal, например с помощью метода string.CompareOrdinal.

//Такой словарь назовём N-граммной моделью текста.

//Реализуйте этот алгоритм в классе FrequencyAnalysisTask.

//Все вопросы и детали уточняйте с помощью примера ниже и тестов.

//Пример
//По тексту a b c d. b c d. e b c a d. должен быть составлен такой словарь:
//        { "a", "b"},
//        {"b", "c"},
//        {"c", "d"},
//        {"e", "b"},
//        {"a b", "c"},
//        {"b c", "d"},
//        {"e b", "c"},
//        {"c a", "d"}

//Обратите внимание:

//из двух биграмм "a b" и "a d", встречающихся однократно, в словаре есть только пара "a": "b", как лексикографически меньшая.
//из двух встречающихся в тексте биграмм "c d" и "c a" в словаре есть только более частотная пара "c": "d".
//из двух триграмм "b c d" и "b c a" в словаре есть только более частотная "b c": "d".

using System.Collections.Generic;

namespace TextAnalysis
{
    static class FrequencyAnalysisTask
    {
        public static Dictionary<string, string> GetMostFrequentNextWords(List<List<string>> text) => NGramFilter(NGramCounter(text));

        public static Dictionary<string, int> NGramCounter(List<List<string>> text) //создание  словаря  которое  содержит  все  вариации  диграмм и  триграмм, словарь в  виде <"ключ", количество повторений>,  
        {
            var tempresult = new Dictionary<string, int>();//ключ представляет собой строку  сформированную  из дву или трех соседних слова, а int просто указывает сколько раз такие комбинации встречались в тексте
            foreach (var sentences in text)
            {
                if (sentences.Count > 1)  //для Nграмм в  предложении должно быть больше 1 слова
                {
                    for (int i = 0; i <= sentences.Count - 2; i++)  //поиск биграмм
                    {
                        if (tempresult.ContainsKey(sentences[i] + "." + sentences[i + 1])) //поиск биграммы в словаре - в  метод определения ключа передается два соседних слова
                            tempresult[sentences[i] + "." + sentences[i + 1]]++;  //если  есть - увеличить значение
                        else
                            tempresult.Add(sentences[i] + "." + sentences[i + 1], 1); //если нет  - добавить, ключ  формируется в  след  виде: начало биграммы (первое слово)  + "."  + конец  триграммы (последнее слово), назначение точки  см  дальше
                        if (sentences.Count > 2 && i <= sentences.Count - 3) //для поиска триграмм  нужны  предложения  длинее  двух слов, 
                        {
                            if (tempresult.ContainsKey(sentences[i] + " " + sentences[i + 1] + "." + sentences[i + 2]))// триграмма это три  (n, n+1, n+2)  соседних  слова в  предложении
                                tempresult[sentences[i] + " " + sentences[i + 1] + "." + sentences[i + 2]]++;   //если наш  словарь  уже  содержит ключ в виде три соседних слова то увеличить это значение, 
                            else
                                tempresult.Add(sentences[i] + " " + sentences[i + 1] + "." + sentences[i + 2], 1); //если  нет,  добавить этот  ключ в  словарь и  установить значение  в 1,  ключ  формируется в  след  виде: начало триграммы (первые  два слова)  + "."  + конец  триграммы
                        }
                    }
                }
            }
            return tempresult;
        }
        public static Dictionary<string, string> NGramFilter(Dictionary<string, int> tempDictionary) //из всех  видом  Nграмм  (биграммы,  триграммы) оставляем  только  те  которые  подходят  под  определенные  условия  (читай дальше)
        {
            var tempresult = new Dictionary<string, string>(); //готовим  итоговый  (результирующий) словарь требуемого формата, здесь ключ это начало Nграммы (первое слово в биграмме или первые два слова в триграмме), а значение в словаре -это последнее слово в Nграмме
            foreach (var tempkey in tempDictionary.Keys)  //начинаем извлекать ключи из подготовленного словаря со всеми комбинациями Nграмм (в данном словаре в ключах и находятся наши Nграммы)
            {
                var keyvalue = tempkey.Split('.');  //т.к.  ключ представляет  собой строку с началом  и концом Nграммы разделенных точкой, то мы их разделяем в временный массив,  первый элемент - ключ(начало Nграммы), второй - значение(конец Nграммы)
                if (!tempresult.ContainsKey(keyvalue[0])) //если в итоговом словаре не содержится текущая Nграмма (поиск по ключю который мы извлекли с  помощью метода Split), то добавляем: 
                    tempresult.Add(keyvalue[0], keyvalue[1]);  //в ключ  - первый элемент массива keyvalue  (начало  Nграммы), в значение - второй элемент массива (конец Nграммы)
                else
                {
                    if (tempDictionary[tempkey] > tempDictionary[keyvalue[0] + "." + tempresult[keyvalue[0]]])  //если начало Nграммы (но не конец!) уже содержится в итоговом словаре, тогда сравниваем частоту встречаемости в тексте обоих комбинаций Nграммы
                        tempresult[keyvalue[0]] = keyvalue[1]; //добавляем/оставляем в словаре только ту комбинацию Nграммы которая встречается чаще в тексте
                    else if (tempDictionary[tempkey] == tempDictionary[keyvalue[0] + "." + tempresult[keyvalue[0]]]) //если  обе комбинации встречаются  одинаково  часто
                        if (string.CompareOrdinal(keyvalue[1], tempresult[keyvalue[0]]) < 0) //выбрать ту комбинацию, чье окончание Nграммы лексикографически  меньше
                            tempresult[keyvalue[0]] = keyvalue[1];  //в ключ  - первый элемент массива keyvalue  (начало  Nграммы), в значение - второй элемент массива (конец Nграммы)
                }
            }
            return tempresult;
        }
    }
}